MIPS32-R1 Standalone
--------------------

The files in this directory create a complete MIPS32 processor. The top-level
module is "Processor.v". The interface includes 5 general-purpose hardware
interrupts, a non-maskable hardware interrupt, the 8 pending ISA interrupts
(for diagnostics--this can be removed), and a memory interface for both
instructions and data.

The memory interface is implemented as a four-way handshake:

    1. Read/Write request goes high.
    2. Ack goes high when data is available.
    3. Read/Write request goes low.
    4. Ack signal goes low.
            ____
    R/W: __|    |____
               ____
    Ack: _____|    |____

This interface is simple and robust but can limit the performance of the
system. In the SoC design this is currently the case, since the instruction
memory fetches only once per handshake. This greatly increases the maximum
theoretical IPC from 1 to between 3 and 4.

If your application requires maximum performance out of this processor,
you should modify the memory handshake accordingly.

==============================================================

The modified memory handshake
-----------------------------

The XUM-MIPS32 processor models memory as an asynchronous RAM with zero
delay, but with some modifications to allow for synchronous pipelined access.

Instruction bus:

At a clock edge, `Inst_Address' is updated by the processor with the address
of the next word to be read from memory.  On the next clock edge, the value
from the memory on the `Inst_In' signal is latched into the instruction
decoder stage.  Conceptually, the memory controller must asynchronously
provide the value addressed by `Inst_Address' in time for it to be latched on
the next clock edge.  If the memory controller is unable to supply the value
by the next clock edge, it must assert `Inst_Stall' for as many clocks as
needed to provide the value.  Another way to look at this is that if
`Inst_Stall' is false, the value on `Inst_In' must be the value addressed by
`Inst_Address'.

Since FPGA memory cells are never asynchronous, and external memory is rarely
asynchronous, two more signals are provided to allow pipelined access to
memory;  If `Inst_Strobe' is true, the value on the `Inst_EarlyAddress'
signal is the address that will become the `Inst_Address' on the next cycle.
The memory controller can use this to latch the required value from memory
before `Inst_Address' becomes valid.  In this way, it is possible to access
memory in continouous single cycle pipelined operation.

Data bus:

The data bus operates in the same way as the instruction bus, but has
additional signals to allow writes to memory.

[ ...more to come... ]



Notes:

*  New cycle started when EarlyStrobe is true.
*  Cycle ends when Stall is false.
*  Data should be captured by the CPU on the cycle that Stall is false,
   but it can be later.
*  Data from the cache (or memory) must remain valid on `In' so long as
   `Address' refers to the same address.  Once `Address' changes, `In'
   becomes invalid.  I-cache implements this by holding the last data
   until the next active cycle (`Address' changes, but `In' doesn't).



// vim:set expandtab shiftwidth=4 softtabstop=4:
